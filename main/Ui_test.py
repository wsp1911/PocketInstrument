# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'e:\Project\Python\PocketInstrument\main\test.ui'
#
# Created by: PyQt5 UI code generator 5.15.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import pyqtSlot, QObject, pyqtSignal
from PyQt5.QtWidgets import QWidget, QMainWindow
from PyQt5.Qt import QThread
import numpy as np
from pyaudio import PyAudio, paInt16, paContinue
import time


class process(QObject):
    def __init__(self, parent=None, win=None):
        super(process, self).__init__(parent=parent)
        self.win = win

    def run(self):
        self.run()

    def run1(self):
        self.win.run1()

    def run2(self):
        self.win.run2()

    #     while self.win.RUNNING1:
    #         if self.win.RUNNING:
    #             self.win.statusbar.showMessage("RUNNING")
    #         else:
    #             self.win.statusbar.showMessage("STOPPED")


class Ui_MainWindow(QMainWindow):
    def __init__(self, parent=None):
        super(Ui_MainWindow, self).__init__(parent=parent)

        # self.CHUNK = 2048
        # self.FORMAT = paInt16  # 表示我们使用量化位数 16位来进行录音
        # self.CHANNELS = 2  # 代表的是声道，1是单声道，2是双声道。
        # self.RATE = 44100  # 采样率 一秒内对声音信号的采集次数，常用的有8kHz, 16kHz, 32kHz, 48kHz, 11.025kHz, 22.05kHz, 44.1kHz。
        # self.play_bytes = (np.zeros(self.CHUNK * 2) * 32768).astype(np.int16).tobytes()
        # self.play_data = np.zeros(self.CHUNK * 2)

        # self.pa = PyAudio()
        # self.stream = self.pa.open(
        #     format=self.FORMAT,
        #     channels=self.CHANNELS,
        #     rate=self.RATE,
        #     input=True,
        #     output=True,
        #     stream_callback=self.callback,
        #     frames_per_buffer=self.CHUNK,
        # )

        self.setObjectName("MainWindow")
        self.resize(800, 600)
        self.centralwidget = QtWidgets.QWidget()
        self.centralwidget.setObjectName("centralwidget")

        self.t1, self.t2 = 0, 0

        self.btn0 = QtWidgets.QPushButton(self.centralwidget)
        self.btn0.setGeometry(QtCore.QRect(0, 0, 200, 50))
        self.btn0.setObjectName("btn0")
        self.btn0.setText("btn0")
        self.btn1 = QtWidgets.QPushButton(self.centralwidget)
        self.btn1.setGeometry(QtCore.QRect(0, 100, 200, 50))
        self.btn1.setObjectName("btn1")
        self.btn1.setText("btn1")

        self.edit0 = QtWidgets.QLabel(self.centralwidget)
        self.edit0.setGeometry(QtCore.QRect(300, 0, 200, 50))
        self.edit0.setObjectName("edit0")
        self.edit1 = QtWidgets.QLabel(self.centralwidget)
        self.edit1.setGeometry(QtCore.QRect(300, 100, 200, 50))
        self.edit1.setObjectName("edit1")

        self.setCentralWidget(self.centralwidget)

        self.menubar = QtWidgets.QMenuBar()
        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 21))
        self.menubar.setObjectName("menubar")
        self.setMenuBar(self.menubar)

        self.statusbar = QtWidgets.QStatusBar()
        self.statusbar.setObjectName("statusbar")
        self.setStatusBar(self.statusbar)

        QtCore.QMetaObject.connectSlotsByName(self)

        self.RUNNING = False
        self.RUNNING1 = False
        self.thread0 = QThread()
        self.thread1 = QThread()
        self.run_obj0 = process(win=self)
        self.run_obj0.moveToThread(self.thread0)
        self.run_obj1 = process(win=self)
        self.run_obj1.moveToThread(self.thread1)

        self.thread0.started.connect(self.run_obj0.run1)
        self.thread1.started.connect(self.run_obj1.run2)

        # self.RUNNING = True
        # self.run1()

    def callback(self, in_data, frame_count, time_info, status):
        data = self.play_bytes
        # print(frame_count)
        if self.RUNNING1:
            self.play_bytes = bytes()
        return (data, paContinue)

    def run(self):
        print("start running")
        i, j = 0, 0
        # perf_t = time.perf_counter()
        # t = np.arange(self.CHUNK) / self.RATE
        f = 100
        t = np.arange(int(self.RATE * 1 / f)) / self.RATE
        y = [0.5 * np.sin(2 * np.pi * f * t), 0.5 * np.cos(2 * np.pi * f * t)]

        # single_t = time.perf_counter()
        # for i in range(10):
        #     for k in range(self.CHUNK):
        #         self.play_data[2 * k] = y[0][i]
        #         self.play_data[2 * k + 1] = y[1][j]
        #         i, j = (i + 1) % len(y[0]), (j + 1) % len(y[1])
        #     self.play_bytes = (self.play_data * 32768).astype(np.int16).tobytes()
        # single_t = (time.perf_counter() - single_t) / 10

        # pa = PyAudio()
        # stream = pa.open(
        #     format=self.FORMAT,
        #     channels=self.CHANNELS,
        #     rate=self.RATE,
        #     input=True,
        #     output=True,
        #     stream_callback=self.callback,
        #     frames_per_buffer=self.CHUNK,
        # )

        while self.RUNNING1:
            if len(self.play_bytes) == 0:
                for k in range(self.CHUNK):
                    self.play_data[2 * k] = y[0][i]
                    self.play_data[2 * k + 1] = y[1][j]
                    i, j = (i + 1) % len(y[0]), (j + 1) % len(y[1])
                self.play_bytes = (self.play_data * 32768).astype(np.int16).tobytes()
            if self.stream.is_stopped():
                self.stream.start_stream()

        if self.stream.is_active():
            self.stream.stop_stream()

        self.play_bytes = (np.zeros(self.CHUNK * 2) * 32768).astype(np.int16).tobytes()
        self.play_data = np.zeros(self.CHUNK * 2)

    def run1(self):
        while self.RUNNING:
            print(str(time.perf_counter() - self.t1))
            self.t1 = time.perf_counter()
            time.sleep(0.5)

    def run2(self):
        while self.RUNNING1:
            print(str(time.perf_counter() - self.t2))
            self.t2 = time.perf_counter()
            time.sleep(1)

    @pyqtSlot()
    def on_btn0_clicked(self):
        self.RUNNING = not self.RUNNING
        if self.RUNNING:
            self.thread0.start()
        else:
            self.thread0.quit()

    @pyqtSlot()
    def on_btn1_clicked(self):
        self.RUNNING1 = not self.RUNNING1
        if self.RUNNING1:
            self.thread1.start()
        else:
            self.thread1.quit()


if __name__ == "__main__":
    import sys

    app = QtWidgets.QApplication(sys.argv)
    ui = Ui_MainWindow()
    ui.show()
    sys.exit(app.exec_())
